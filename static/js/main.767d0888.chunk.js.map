{"version":3,"sources":["components/FrequencyGraph/FrequencyGraph.jsx","components/LiveFrequencyGraph/LiveFrequencyGraph.jsx","components/Player/Timeline/Timeline.jsx","components/Player/PlayPause/PlayPause.jsx","components/Player/AudioOpener/AudioOpener.jsx","components/Player/Player.jsx","App.jsx","index.js"],"names":["PureComponent","Timeline","_getPrototypeOf2","_this","Object","classCallCheck","this","_len","arguments","length","args","Array","_key","possibleConstructorReturn","getPrototypeOf","call","apply","concat","state","secondsPerPixel","resize","bind","assertThisInitialized","props","audioBuffer","renderCanvas","window","addEventListener","removeEventListener","ctx","canvas","width","Math","ceil","duration","height","audioCtx","OfflineAudioContext","sampleRate","sourceNode","createBufferSource","buffer","analyzerNode","createAnalyser","fftSize","smoothingTimeConstant","connect","destination","start","suspendTimes","from","value","index","_this2","frequencySlicesByTimePromises","map","_ref","asyncToGenerator","regenerator_default","a","mark","_callee","time","frequencyData","wrap","_context","prev","next","suspend","Uint8Array","frequencyBinCount","getByteFrequencyData","resume","abrupt","stop","_x","rendering","startRendering","Promise","all","frequencySlicesByTime","canvasWidth","canvasHeight","imageData","getImageData","buf","ArrayBuffer","data","buf8","Uint8ClampedArray","Uint32Array","y","x","gradient","set","putImageData","forceUpdate","_this3","offsetPixels","min","max","currentTime","parentElement","clientWidth","react_default","createElement","className","ref","getContext","style","marginLeft","left","type","toString","step","onInput","onCurrentTimeChange","onClick","onChange","disabled","isPlaying","isWorking","id","accept","e","openFile","target","files","setState","reader","FileReader","onload","audioContext","decodeAudioData","result","sent","onOpen","readAsArrayBuffer","Player","audioBufferKey","startTime","AudioContext","Timeline_Timeline","currentTimeChanged","key","PlayPause_Timeline","pause","play","AudioOpener_Timeline","fileOpened","disconnect","requestAnimationFrame","_this4","updateCurrentTime","_this5","_this6","App","working","Player_Player","console","log","source","Component","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","render","react","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.767d0888.chunk.js","sourcesContent":["import React, { PureComponent } from 'react'\r\nimport gradient from '../gradient.json'\r\n\r\nexport default class FrequencyGraph extends PureComponent {\r\n  constructor (...args) {\r\n    super(...args)\r\n    this.state = {\r\n      working: true\r\n    }\r\n  }\r\n  async componentDidMount () {\r\n    this.canvas.width = 1000\r\n    this.canvas.height = 512\r\n    this.ctx = this.canvas.getContext('2d')\r\n  }\r\n  async componentDidUpdate () {\r\n    if (!this.props.buffer) return\r\n    const audioCtx = new OfflineAudioContext(2, this.props.buffer.length, this.props.buffer.sampleRate)\r\n\r\n    const sourceNode = audioCtx.createBufferSource()\r\n    sourceNode.buffer = this.props.buffer\r\n    const analyzerNode = audioCtx.createAnalyser()\r\n    analyzerNode.fftSize = this.canvas.height * 2\r\n    analyzerNode.smoothingTimeConstant = 0\r\n    sourceNode.connect(analyzerNode)\r\n    analyzerNode.connect(audioCtx.destination)\r\n    sourceNode.start()\r\n\r\n    const suspendTimes = Array.from({ length: this.canvas.width }, (value, index) => this.props.buffer.duration / this.canvas.width * index)\r\n    const frequencySlicesByTimePromises = suspendTimes\r\n      .map(async time => {\r\n        await audioCtx.suspend(time)\r\n        const frequencyData = new Uint8Array(analyzerNode.frequencyBinCount)\r\n        analyzerNode.getByteFrequencyData(frequencyData)\r\n        await audioCtx.resume()\r\n        return frequencyData\r\n      })\r\n    const renderingPromise = audioCtx.startRendering()\r\n    const frequencySlicesByTime = await Promise.all(frequencySlicesByTimePromises)\r\n\r\n    const canvasWidth = this.canvas.width\r\n    const canvasHeight = this.canvas.height\r\n    const imageData = this.ctx.getImageData(0, 0, canvasWidth, canvasHeight)\r\n\r\n    const buf = new ArrayBuffer(imageData.data.length)\r\n    const buf8 = new Uint8ClampedArray(buf)\r\n    const data = new Uint32Array(buf)\r\n\r\n    for (let y = 0; y < canvasHeight; ++y) {\r\n      for (let x = 0; x < canvasWidth; ++x) {\r\n        const value = frequencySlicesByTime[x][canvasHeight - y - 1]\r\n        data[y * canvasWidth + x] =\r\n                (255 << 24) | // alpha\r\n                (gradient[value][2] << 16) | // blue\r\n                (gradient[value][1] << 8) | // green\r\n                gradient[value][0] // red\r\n      }\r\n    }\r\n\r\n    imageData.data.set(buf8)\r\n    this.ctx.putImageData(imageData, 0, 0)\r\n    await renderingPromise\r\n  }\r\n  render () {\r\n    return <canvas\r\n      style={{ background: 'black', display: 'block' }}\r\n      ref={(ref) => this.canvas = ref} />\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react'\r\nimport gradient from '../gradient.json'\r\n\r\nexport default class FrequencyGraph extends PureComponent {\r\n  constructor (...args) {\r\n    super(...args)\r\n    this.state = {\r\n      working: true\r\n    }\r\n  }\r\n  async componentDidMount () {\r\n    this.canvas.width = Math.round(document.body.clientWidth / 2) * 2\r\n    this.canvas.height = 512\r\n    this.ctx = this.canvas.getContext('2d')\r\n  }\r\n  async componentDidUpdate () {\r\n    if (this.props.fromNode && this.props.audioContext && !this.state.animating) {\r\n      this.splitterNode = this.props.audioContext.createChannelSplitter(2)\r\n      this.analyzerNodeLeft = this.props.audioContext.createAnalyser()\r\n      this.analyzerNodeRight = this.props.audioContext.createAnalyser()\r\n      this.analyzerNodeLeft.fftSize = this.canvas.height * 2\r\n      this.analyzerNodeLeft.smoothingTimeConstant = 0\r\n      this.analyzerNodeRight.fftSize = this.canvas.height * 2\r\n      this.analyzerNodeRight.smoothingTimeConstant = 0\r\n      this.props.fromNode.connect(this.splitterNode)\r\n      this.splitterNode.connect(this.analyzerNodeLeft, 0)\r\n      this.splitterNode.connect(this.analyzerNodeRight, 0)\r\n      this.animate()\r\n      debugger\r\n      this.setState({ animating: true })\r\n    }\r\n  }\r\n  animate () {\r\n    requestAnimationFrame(this.animate.bind(this))\r\n    const frequencyDataLeft = new Uint8Array(this.analyzerNodeLeft.frequencyBinCount)\r\n    this.analyzerNodeLeft.getByteFrequencyData(frequencyDataLeft)\r\n    const frequencyDataRight = new Uint8Array(this.analyzerNodeRight.frequencyBinCount)\r\n    this.analyzerNodeRight.getByteFrequencyData(frequencyDataRight)\r\n    const canvasWidth = this.canvas.width\r\n    const canvasHeight = this.canvas.height\r\n    const imageDataLeft = this.ctx.getImageData(canvasWidth / 2 - 1, 0, 1, canvasHeight)\r\n    const imageDataRight = this.ctx.getImageData(canvasWidth / 2, 0, 1, canvasHeight)\r\n\r\n    const bufLeft = new ArrayBuffer(imageDataLeft.data.length)\r\n    const buf8Left = new Uint8ClampedArray(bufLeft)\r\n    const dataLeft = new Uint32Array(bufLeft)\r\n\r\n    for (let y = 0; y < canvasHeight; y++) {\r\n      const value = frequencyDataLeft[y]\r\n      dataLeft[canvasHeight - y] =\r\n        (255 << 24) | // alpha\r\n        (gradient[value][2] << 16) | // blue\r\n        (gradient[value][1] << 8) | // green\r\n        gradient[value][0] // red\r\n    }\r\n\r\n    const bufRight = new ArrayBuffer(imageDataRight.data.length)\r\n    const buf8Right = new Uint8ClampedArray(bufRight)\r\n    const dataRight = new Uint32Array(bufRight)\r\n\r\n    for (let y = 0; y < canvasHeight; y++) {\r\n      const value = frequencyDataRight[y]\r\n      dataRight[canvasHeight - y] =\r\n          (255 << 24) | // alpha\r\n          (gradient[value][2] << 16) | // blue\r\n          (gradient[value][1] << 8) | // green\r\n          gradient[value][0] // red\r\n    }\r\n\r\n    imageDataLeft.data.set(buf8Left)\r\n    imageDataRight.data.set(buf8Right)\r\n\r\n    this.ctx.drawImage(this.ctx.canvas, 0, 0, this.canvas.width / 2, this.canvas.height, -1, 0, this.canvas.width / 2, this.canvas.height)\r\n    this.ctx.drawImage(this.ctx.canvas, this.canvas.width / 2, 0, this.canvas.width / 2, this.canvas.height, this.canvas.width / 2 + 1, 0, this.canvas.width / 2, this.canvas.height)\r\n    this.ctx.putImageData(imageDataLeft, this.canvas.width / 2 - 1, 0)\r\n    this.ctx.putImageData(imageDataRight, this.canvas.width / 2, 0)\r\n    // this.ctx.putImageData(imageDataRight, this.canvas.width/2+2, 0)\r\n    // this.ctx.putImageData(imageDataRight, this.canvas.width/2+3, 0)\r\n  }\r\n  render () {\r\n    return <canvas\r\n      style={{ background: 'black', display: 'block' }}\r\n      ref={(ref) => this.canvas = ref} />\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react'\r\nimport gradient from '../../gradient.json'\r\nimport './style.css'\r\n\r\nexport default class Timeline extends PureComponent {\r\n  constructor(...args) {\r\n    super(...args)\r\n    this.state = {\r\n      secondsPerPixel: 0.02,\r\n    }\r\n    this.resize = this.resize.bind(this)\r\n  }\r\n  componentDidMount() {\r\n    if (this.props.audioBuffer)\r\n      this.renderCanvas()\r\n    window.addEventListener('resize', this.resize)\r\n  }\r\n  componentWillUnmount() {\r\n    window.removeEventListener('resize', this.resize)\r\n  }\r\n  async renderCanvas() {\r\n    this.ctx.canvas.width = Math.ceil(this.props.audioBuffer ? this.props.audioBuffer.duration / this.state.secondsPerPixel : 0)\r\n    this.ctx.canvas.height = 1024\r\n\r\n    const audioCtx = new window.OfflineAudioContext(2, this.props.audioBuffer.length, this.props.audioBuffer.sampleRate)\r\n\r\n    const sourceNode = audioCtx.createBufferSource()\r\n    sourceNode.buffer = this.props.audioBuffer\r\n    const analyzerNode = audioCtx.createAnalyser()\r\n    analyzerNode.fftSize = this.ctx.canvas.height * 2\r\n    analyzerNode.smoothingTimeConstant = 0\r\n    sourceNode.connect(analyzerNode)\r\n    analyzerNode.connect(audioCtx.destination)\r\n    sourceNode.start()\r\n\r\n    const suspendTimes = Array.from({ length: this.ctx.canvas.width }, (value, index) => this.state.secondsPerPixel * index)\r\n    const frequencySlicesByTimePromises = suspendTimes\r\n      .map(async time => {\r\n        await audioCtx.suspend(time)\r\n        const frequencyData = new Uint8Array(analyzerNode.frequencyBinCount)\r\n        analyzerNode.getByteFrequencyData(frequencyData)\r\n        await audioCtx.resume()\r\n        return frequencyData\r\n      })\r\n    const rendering = audioCtx.startRendering()\r\n    const frequencySlicesByTime = await Promise.all(frequencySlicesByTimePromises)\r\n    const canvasWidth = this.ctx.canvas.width\r\n    const canvasHeight = this.ctx.canvas.height\r\n    const imageData = this.ctx.getImageData(0, 0, canvasWidth, canvasHeight)\r\n\r\n    const buf = new ArrayBuffer(imageData.data.length)\r\n    const buf8 = new Uint8ClampedArray(buf)\r\n    const data = new Uint32Array(buf)\r\n\r\n    for (let y = 0; y < canvasHeight; ++y) {\r\n      for (let x = 0; x < canvasWidth; ++x) {\r\n        const value = frequencySlicesByTime[x][canvasHeight - y - 1]\r\n        data[y * canvasWidth + x] =\r\n                (255 << 24) | // alpha\r\n                (gradient[value][2] << 16) | // blue\r\n                (gradient[value][1] << 8) | // green\r\n                gradient[value][0] // red\r\n      }\r\n    }\r\n    imageData.data.set(buf8)\r\n    this.ctx.putImageData(imageData, 0, 0)\r\n    await rendering\r\n  }\r\n  resize () {\r\n    this.forceUpdate()\r\n  }\r\n  render () {\r\n    const offsetPixels = Math.min(\r\n      this.ctx ? Math.max(this.props.currentTime / this.state.secondsPerPixel - this.ctx.canvas.parentElement.clientWidth / 2, 0) : 0,\r\n      this.ctx ? this.props.audioBuffer.duration / this.state.secondsPerPixel - this.ctx.canvas.parentElement.clientWidth : 0\r\n    )\r\n    return <div className='timeline'>\r\n      <div className='frequencygraph'>\r\n        <canvas\r\n          ref={canvas => this.ctx = canvas && canvas.getContext('2d')}\r\n          style={{marginLeft: -offsetPixels}}\r\n        ></canvas>\r\n        <div className='timelinepointer' style={{left: this.props.currentTime / this.state.secondsPerPixel - offsetPixels}} />\r\n      </div>\r\n      <input type=\"range\" min=\"0\" max={this.props.audioBuffer ? this.props.audioBuffer.duration.toString() : \"0\"} step=\"0.01\" value={this.props.currentTime} onInput={this.props.onCurrentTimeChange}/>\r\n    </div>\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react'\r\nimport './style.css'\r\n\r\nexport default class Timeline extends PureComponent {\r\n  render () {\r\n    return <div className='playpause'>\r\n      <button onClick={this.props.onChange} disabled={this.props.disabled}>{this.props.isPlaying ? 'Pause' : 'Play'}</button>\r\n    </div>\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react'\r\nimport './style.css'\r\n\r\nexport default class Timeline extends PureComponent {\r\n  constructor (...args) {\r\n    super(...args)\r\n    this.state = {\r\n      isWorking: false\r\n    }\r\n  }\r\n  render () {\r\n    return <div className='audioopener'>\r\n      <input type='file' id='input' accept='audio/*' onChange={(e) => this.openFile(e)} disabled={this.state.isWorking} />\r\n    </div>\r\n  }\r\n  openFile (e) {\r\n    if (!e.target.files.length) return\r\n    this.setState({ isWorking: true })\r\n    const reader = new window.FileReader()\r\n    reader.onload = async (e) => {\r\n      const buffer = await this.props.audioContext.decodeAudioData(e.target.result)\r\n      this.setState({ isWorking: false })\r\n      this.props.onOpen(buffer)\r\n    }\r\n    reader.readAsArrayBuffer(e.target.files[0])\r\n  }\r\n}\r\n","import React, { PureComponent } from 'react'\r\nimport Timeline from './Timeline/Timeline'\r\nimport PlayPause from './PlayPause/PlayPause'\r\nimport AudioOpener from './AudioOpener/AudioOpener'\r\n\r\nimport './style.css'\r\n\r\nexport default class Player extends PureComponent {\r\n  constructor (...args) {\r\n    super(...args)\r\n    this.state = {\r\n      audioBuffer: null,\r\n      audioBufferKey: 0,\r\n      currentTime: 0, // time in playing file (in seconds)\r\n      startTime: 0, // time of file start in audioContext's reference system\r\n      isPlaying: false\r\n    }\r\n    this.audioContext = new window.AudioContext()\r\n    this.sourceNode = null\r\n  }\r\n  render () {\r\n    return <div className='player'>\r\n      <Timeline audioBuffer={this.state.audioBuffer} currentTime={this.state.currentTime} onCurrentTimeChange={(e) => this.currentTimeChanged(+e.target.value)} key={this.state.audioBufferKey}/>\r\n      <PlayPause isPlaying={this.state.isPlaying} onChange={this.state.isPlaying ? () => this.pause() : () => this.play()} disabled={!this.state.audioBuffer} />\r\n      <AudioOpener audioContext={this.audioContext} onOpen={(buffer) => { this.fileOpened(buffer); this.play() }} />\r\n    </div>\r\n  }\r\n  fileOpened (buffer) {\r\n    this.setState((state) => ({\r\n      audioBuffer: buffer,\r\n      audioBufferKey: state.audioBufferKey + 1,\r\n      currentTime: 0,\r\n      startTime: this.audioContext.currentTime\r\n    }), () => {\r\n      if (this.state.isPlaying) {\r\n        this.play()\r\n      }\r\n    })\r\n  }\r\n  async play (time = this.state.currentTime) {\r\n    if (!this.state.audioBuffer) return\r\n    if (this.audioContext.state === 'suspended') {\r\n      await this.audioContext.resume()\r\n    }\r\n    if (this.sourceNode) {\r\n      this.sourceNode.disconnect()\r\n      this.sourceNode.stop()\r\n    }\r\n    this.sourceNode = this.audioContext.createBufferSource()\r\n    this.sourceNode.connect(this.audioContext.destination)\r\n    this.sourceNode.buffer = this.state.audioBuffer\r\n    this.sourceNode.start(0, time)\r\n    if (!this.state.isPlaying) {\r\n      requestAnimationFrame(() => this.updateCurrentTime())\r\n    }\r\n    this.setState({\r\n      isPlaying: true,\r\n      startTime: this.audioContext.currentTime - time\r\n    })\r\n  }\r\n  updateCurrentTime() {\r\n    this.setState(state => {\r\n      if (this.state.isPlaying) {\r\n        return {\r\n          currentTime: this.audioContext.currentTime - state.startTime\r\n        }\r\n      }\r\n      return {}\r\n    }, () => this.state.isPlaying && requestAnimationFrame(() => this.updateCurrentTime()))\r\n  }\r\n  async pause () {\r\n    this.sourceNode.disconnect()\r\n    this.sourceNode.stop()\r\n    this.sourceNode = null\r\n    this.setState(state => ({\r\n      isPlaying: false,\r\n      currentTime: this.audioContext.currentTime - state.startTime\r\n    }))\r\n  }\r\n  currentTimeChanged (time) {\r\n    if (this.state.isPlaying) {\r\n      this.play(time)\r\n    } else {\r\n      this.setState({\r\n        currentTime: time\r\n      })\r\n    }\r\n  }\r\n}\r\n","import React, { Component } from 'react'\r\nimport './App.css'\r\n\r\nimport FrequencyGraph from './components/FrequencyGraph/FrequencyGraph'\r\nimport LiveFrequencyGraph from './components/LiveFrequencyGraph/LiveFrequencyGraph'\r\nimport Player from './components/Player/Player'\r\n\r\nclass App extends Component {\r\n  constructor (...args) {\r\n    super(...args)\r\n    this.audioContext = new AudioContext()\r\n    this.state = {\r\n      working: false,\r\n      audioBuffer: null\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return <div className='App'>\r\n      {/* <input type=\"file\" id=\"input\" accept=\"audio/*\" onChange={this.openFile}/>\r\n      <button onClick={this.play} disabled={this.state.working || !this.source}>Play</button>\r\n      <FrequencyGraph buffer={this.state.audioBuffer}></FrequencyGraph> */}\r\n      <Player />\r\n      {/* <LiveFrequencyGraph audioContext={this.audioContext} fromNode={this.source}></LiveFrequencyGraph> */}\r\n    </div>\r\n  };\r\n\r\n  async play () {\r\n    console.log(this.audioContext.state)\r\n    if (this.audioContext.state === 'suspended') {\r\n      await this.audioContext.resume()\r\n      console.log('resumed')\r\n    }\r\n    this.source.start(0)\r\n    console.log('started')\r\n  }\r\n}\r\n\r\nexport default App\r\n","import React, { StrictMode } from 'react'\r\nimport { render } from 'react-dom'\r\nimport { Provider } from 'react-redux'\r\nimport { createStore, applyMiddleware, compose } from 'redux'\r\nimport thunk from 'redux-thunk'\r\n\r\nimport App from './App'\r\n// import * as serviceWorker from './serviceWorker';\r\n\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose\r\n// const store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunk)))\r\n\r\nrender(\r\n  <StrictMode>\r\n    <App />\r\n  </StrictMode>,\r\n  document.getElementById('root')\r\n)\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\n// serviceWorker.unregister();\r\n"],"sourceRoot":""}